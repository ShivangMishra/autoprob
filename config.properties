######## katago settings

katago=/opt/homebrew/bin/katago
kata.config=/opt/homebrew/Cellar/katago/1.11.0/share/katago/configs/analysis_example.cfg
#kata.model=/opt/homebrew/Cellar/katago/1.11.0/share/katago/g170e-b20c256x2-s5303129600-d1228401921.bin.gz
kata.model=/Users/adammiller/Downloads/kata1-b15c192-s1672170752-d466197061.txt.gz
# prints directly all text returned by katago
kata.debugprint=false
# prints query going in to katago from node analyzer
kata.printanalyzerquery=false
# prints one line summary of a query result
kata.printsummaryresult=false

######## search settings

# visit count for katago when searching through a game
search.visits=1200
# when a potential problem is found, this many visits to double check its properties. Typically a lot higher than search.visits
search.root_visits=5000
# max problems to find in directory search
search.directory.max_finds=20

# if search requires a mistake, problems will only be considered where the original player made a big mistake in this position. The idea behind setting this true is to make sure problems are from real world positions where a human made a mistake, and thus might be a better learning opportunity. Obviously this generates way fewer problems.
search.requiremistake=false
# maxpolicy is the maximum katago policy value for a solution in order for this to be an interesting problem. Values from 0 to 1. Lower values ensure less obvious problems.
search.maxpolicy=0.6
# no more than this many correct moves to solve a problem
search.maxsolutions=1
# disallow problems where prev move was ko
search.nolastkomove=true
search.debugpassownership=true

# how much the katago concept of ownership (from -1 to 1) has to change absolutely to consider this stone changing sides
search.ownership_threshold=1.3

# set turn to look only at a specific move in a specific game. The numbering is what katago would use.
#turn=207

# set forceproblem to true (only when looking at a specific move in one game) to force this to be detected as a problem
#forceproblem=true

######## problem extraction
extract.debugprintownership=true

######## problem path creation

# stop open exploring after this number of nodes have been added to the tree (still do key paths)
paths.bailnumber=40
# stop generating paths after this depth in the tree (ending on human move for correct paths, refutation move otherwise)
# paths.max_depth=5

# optional: specify only top level moves katago will explore
#paths.only_try_moves=A1,T17

# visits in root problem node
paths.visits_root=6000
# visits in every other node
paths.visits=1000

# policy is between 0-1000 and means how likely the net thought this move would be
# min_policy here is a list of minimum policy values corresponding to a depth in the tree
# a move must meet this minimum in order to be considered interesting
# (the final policy value is assumed to continue as the tree deepens)
# generally the policies should increase so as you get deeper in the tree, the moves are required to be more interesting
# note that human vs problem response alternates. response only matters in correct vars (incorrect vars always responded to)
paths.min_policy=20,100,100,100,150,200,400

# pass moves are used to consider a counter-factual, should a response not be made
# when checking value of a pass, use this number of visits for establishing the base situation
paths.passvisitsbase=2000
# when checking value of a pass, use this number of visits for evaluating after a pass
paths.passvisitspass=2000

# debug ownership by printing it out
paths.debug_ownership=false
# print this number of candidate moves from katago results
paths.debug_print_moves=0

######## output

# write a file with the problem in sgf format?
output.write_file=true
# output path for problems
output.path=autoproblem.sgf
